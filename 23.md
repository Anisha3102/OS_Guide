# What are ways to handle deadlock (prevention, avoidance, detection, recovery)?

## Ways to Handle Deadlock

There are four main strategies:

## 1 Deadlock Prevention

Idea: Ensure that at least one of the Coffman‚Äôs conditions never holds.

Methods:

Mutual Exclusion ‚Üí Make resources sharable if possible (e.g., read-only files).

Hold and Wait ‚Üí Require processes to request all resources at once (may cause underutilization).

No Preemption ‚Üí If a process cannot get a resource, force it to release what it holds.

Circular Wait ‚Üí Impose a global ordering of resources (processes must request in increasing order).

-  Pro: No deadlock.

- Con: May reduce resource utilization, cause starvation.

## 2Ô∏è Deadlock Avoidance

Idea: The system examines requests before granting to ensure it never enters an unsafe state.

Technique:

Banker‚Äôs Algorithm ‚Üí Allocates resources only if it leaves the system in a safe state.

- Pro: More flexible than prevention.

- Con: Requires advance knowledge of maximum resource needs; high overhead.

## 3Ô∏è Deadlock Detection and Recovery

Idea: Let deadlocks happen, but detect and fix them.

Detection:

Use a Wait-for Graph (WFG) ‚Üí detect cycles ‚Üí indicates deadlock.

Recovery:

Terminate processes (abort all or one by one until deadlock breaks).

Resource preemption (take resources from some processes).

- Pro: Works when deadlocks are rare.

- Con: Recovery may be expensive; terminating processes can cause data loss.

## 4 Ignore the Problem (Ostrich Algorithm ü¶¢)

Many OS (like Windows, Linux) simply ignore deadlocks, assuming they‚Äôre rare.

- Pro: Simple, no overhead.

- Con: Deadlocks may freeze processes forever.